{"ast":null,"code":"const {\n  slice,\n  forEach\n} = [];\nfunction defaults(obj) {\n  forEach.call(slice.call(arguments, 1), source => {\n    if (source) {\n      for (const prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\nfunction hasXSS(input) {\n  if (typeof input !== 'string') return false;\n\n  // Common XSS attack patterns\n  const xssPatterns = [/<\\s*script.*?>/i, /<\\s*\\/\\s*script\\s*>/i, /<\\s*img.*?on\\w+\\s*=/i, /<\\s*\\w+\\s*on\\w+\\s*=.*?>/i, /javascript\\s*:/i, /vbscript\\s*:/i, /expression\\s*\\(/i, /eval\\s*\\(/i, /alert\\s*\\(/i, /document\\.cookie/i, /document\\.write\\s*\\(/i, /window\\.location/i, /innerHTML/i];\n  return xssPatterns.some(pattern => pattern.test(input));\n}\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nconst serializeCookie = function (name, val) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    path: '/'\n  };\n  const opt = options;\n  const value = encodeURIComponent(val);\n  let str = \"\".concat(name, \"=\").concat(value);\n  if (opt.maxAge > 0) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += \"; Max-Age=\".concat(Math.floor(maxAge));\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += \"; Domain=\".concat(opt.domain);\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += \"; Path=\".concat(opt.path);\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n    str += \"; Expires=\".concat(opt.expires.toUTCString());\n  }\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  if (opt.partitioned) str += '; Partitioned';\n  return str;\n};\nconst cookie = {\n  create(name, value, minutes, domain) {\n    let cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, value, cookieOptions);\n  },\n  read(name) {\n    const nameEQ = \"\".concat(name, \"=\");\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  },\n  remove(name, domain) {\n    this.create(name, '', -1, domain);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  // Deconstruct the options object and extract the lookupCookie property\n  lookup(_ref) {\n    let {\n      lookupCookie\n    } = _ref;\n    if (lookupCookie && typeof document !== 'undefined') {\n      return cookie.read(lookupCookie) || undefined;\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupCookie,\n      cookieMinutes,\n      cookieDomain,\n      cookieOptions\n    } = _ref2;\n    if (lookupCookie && typeof document !== 'undefined') {\n      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);\n    }\n  }\n};\nvar querystring = {\n  name: 'querystring',\n  // Deconstruct the options object and extract the lookupQuerystring property\n  lookup(_ref) {\n    let {\n      lookupQuerystring\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      var _window$location$hash;\n      let {\n        search\n      } = window.location;\n      if (!window.location.search && ((_window$location$hash = window.location.hash) === null || _window$location$hash === void 0 ? void 0 : _window$location$hash.indexOf('?')) > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n      const query = search.substring(1);\n      const params = query.split('&');\n      for (let i = 0; i < params.length; i++) {\n        const pos = params[i].indexOf('=');\n        if (pos > 0) {\n          const key = params[i].substring(0, pos);\n          if (key === lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n    return found;\n  }\n};\nvar hash = {\n  name: 'hash',\n  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property\n  lookup(_ref) {\n    let {\n      lookupHash,\n      lookupFromHashIndex\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      const {\n        hash\n      } = window.location;\n      if (hash && hash.length > 2) {\n        const query = hash.substring(1);\n        if (lookupHash) {\n          const params = query.split('&');\n          for (let i = 0; i < params.length; i++) {\n            const pos = params[i].indexOf('=');\n            if (pos > 0) {\n              const key = params[i].substring(0, pos);\n              if (key === lookupHash) {\n                found = params[i].substring(pos + 1);\n              }\n            }\n          }\n        }\n        if (found) return found;\n        if (!found && lookupFromHashIndex > -1) {\n          var _language$index;\n          const language = hash.match(/\\/([a-zA-Z-]*)/g);\n          if (!Array.isArray(language)) return undefined;\n          const index = typeof lookupFromHashIndex === 'number' ? lookupFromHashIndex : 0;\n          return (_language$index = language[index]) === null || _language$index === void 0 ? void 0 : _language$index.replace('/', '');\n        }\n      }\n    }\n    return found;\n  }\n};\nlet hasLocalStorageSupport = null;\nconst localStorageAvailable = () => {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n  try {\n    hasLocalStorageSupport = typeof window !== 'undefined' && window.localStorage !== null;\n    if (!hasLocalStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n  return hasLocalStorageSupport;\n};\nvar localStorage = {\n  name: 'localStorage',\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  lookup(_ref) {\n    let {\n      lookupLocalStorage\n    } = _ref;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      return window.localStorage.getItem(lookupLocalStorage) || undefined; // Undefined ensures type consistency with the previous version of this function\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupLocalStorage\n    } = _ref2;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(lookupLocalStorage, lng);\n    }\n  }\n};\nlet hasSessionStorageSupport = null;\nconst sessionStorageAvailable = () => {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n  try {\n    hasSessionStorageSupport = typeof window !== 'undefined' && window.sessionStorage !== null;\n    if (!hasSessionStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n  return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup(_ref) {\n    let {\n      lookupSessionStorage\n    } = _ref;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      return window.sessionStorage.getItem(lookupSessionStorage) || undefined;\n    }\n    return undefined;\n  },\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupSessionStorage\n    } = _ref2;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(lookupSessionStorage, lng);\n    }\n  }\n};\nvar navigator$1 = {\n  name: 'navigator',\n  lookup(options) {\n    const found = [];\n    if (typeof navigator !== 'undefined') {\n      const {\n        languages,\n        userLanguage,\n        language\n      } = navigator;\n      if (languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (let i = 0; i < languages.length; i++) {\n          found.push(languages[i]);\n        }\n      }\n      if (userLanguage) {\n        found.push(userLanguage);\n      }\n      if (language) {\n        found.push(language);\n      }\n    }\n    return found.length > 0 ? found : undefined;\n  }\n};\nvar htmlTag = {\n  name: 'htmlTag',\n  // Deconstruct the options object and extract the htmlTag property\n  lookup(_ref) {\n    let {\n      htmlTag\n    } = _ref;\n    let found;\n    const internalHtmlTag = htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === 'function') {\n      found = internalHtmlTag.getAttribute('lang');\n    }\n    return found;\n  }\n};\nvar path = {\n  name: 'path',\n  // Deconstruct the options object and extract the lookupFromPathIndex property\n  lookup(_ref) {\n    var _language$index2;\n    let {\n      lookupFromPathIndex\n    } = _ref;\n    if (typeof window === 'undefined') return undefined;\n    const language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n    if (!Array.isArray(language)) return undefined;\n    const index = typeof lookupFromPathIndex === 'number' ? lookupFromPathIndex : 0;\n    return (_language$index2 = language[index]) === null || _language$index2 === void 0 ? void 0 : _language$index2.replace('/', '');\n  }\n};\nvar subdomain = {\n  name: 'subdomain',\n  lookup(_ref) {\n    var _window$location;\n    let {\n      lookupFromSubdomainIndex\n    } = _ref;\n    // If given get the subdomain index else 1\n    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === 'number' ? lookupFromSubdomainIndex + 1 : 1;\n    // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group match which should be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n    const language = typeof window !== 'undefined' && ((_window$location = window.location) === null || _window$location === void 0 || (_window$location = _window$location.hostname) === null || _window$location === void 0 ? void 0 : _window$location.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i));\n\n    // if there is no match (null) return undefined\n    if (!language) return undefined;\n    // return the given group match\n    return language[internalLookupFromSubdomainIndex];\n  }\n};\n\n// some environments, throws when accessing document.cookie\nlet canCookies = false;\ntry {\n  // eslint-disable-next-line no-unused-expressions\n  document.cookie;\n  canCookies = true;\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nconst order = ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'];\nif (!canCookies) order.splice(1, 1);\nconst getDefaults = () => ({\n  order,\n  lookupQuerystring: 'lng',\n  lookupCookie: 'i18next',\n  lookupLocalStorage: 'i18nextLng',\n  lookupSessionStorage: 'i18nextLng',\n  // cache user language\n  caches: ['localStorage'],\n  excludeCacheFor: ['cimode'],\n  // cookieMinutes: 10,\n  // cookieDomain: 'myDomain'\n\n  convertDetectedLanguage: l => l\n});\nclass Browser {\n  constructor(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n  init() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      languageUtils: {}\n    };\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.services = services;\n    this.options = defaults(options, this.options || {}, getDefaults());\n    if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {\n      this.options.convertDetectedLanguage = l => l.replace('-', '_');\n    }\n\n    // backwards compatibility\n    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n    this.i18nOptions = i18nOptions;\n    this.addDetector(cookie$1);\n    this.addDetector(querystring);\n    this.addDetector(localStorage);\n    this.addDetector(sessionStorage);\n    this.addDetector(navigator$1);\n    this.addDetector(htmlTag);\n    this.addDetector(path);\n    this.addDetector(subdomain);\n    this.addDetector(hash);\n  }\n  addDetector(detector) {\n    this.detectors[detector.name] = detector;\n    return this;\n  }\n  detect() {\n    let detectionOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.order;\n    let detected = [];\n    detectionOrder.forEach(detectorName => {\n      if (this.detectors[detectorName]) {\n        let lookup = this.detectors[detectorName].lookup(this.options);\n        if (lookup && typeof lookup === 'string') lookup = [lookup];\n        if (lookup) detected = detected.concat(lookup);\n      }\n    });\n    detected = detected.filter(d => d !== undefined && d !== null && !hasXSS(d)).map(d => this.options.convertDetectedLanguage(d));\n    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n    return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n  }\n  cacheUserLanguage(lng) {\n    let caches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.caches;\n    if (!caches) return;\n    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n    caches.forEach(cacheName => {\n      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);\n    });\n  }\n}\nBrowser.type = 'languageDetector';\nexport { Browser as default };","map":{"version":3,"names":["slice","forEach","defaults","obj","call","arguments","source","prop","undefined","hasXSS","input","xssPatterns","some","pattern","test","fieldContentRegExp","serializeCookie","name","val","options","length","path","opt","value","encodeURIComponent","str","concat","maxAge","Number","isNaN","Error","Math","floor","domain","TypeError","expires","toUTCString","httpOnly","secure","sameSite","toLowerCase","partitioned","cookie","create","minutes","cookieOptions","Date","setTime","getTime","document","read","nameEQ","ca","split","i","c","charAt","substring","indexOf","remove","cookie$1","lookup","_ref","lookupCookie","cacheUserLanguage","lng","_ref2","cookieMinutes","cookieDomain","querystring","lookupQuerystring","found","window","_window$location$hash","search","location","hash","query","params","pos","key","lookupHash","lookupFromHashIndex","_language$index","language","match","Array","isArray","index","replace","hasLocalStorageSupport","localStorageAvailable","localStorage","testKey","setItem","removeItem","e","lookupLocalStorage","getItem","hasSessionStorageSupport","sessionStorageAvailable","sessionStorage","lookupSessionStorage","navigator$1","navigator","languages","userLanguage","push","htmlTag","internalHtmlTag","documentElement","getAttribute","_language$index2","lookupFromPathIndex","pathname","subdomain","_window$location","lookupFromSubdomainIndex","internalLookupFromSubdomainIndex","hostname","canCookies","order","splice","getDefaults","caches","excludeCacheFor","convertDetectedLanguage","l","Browser","constructor","services","type","detectors","init","languageUtils","i18nOptions","lookupFromUrlIndex","addDetector","detector","detect","detectionOrder","detected","detectorName","filter","d","map","getBestMatchFromCodes","cacheName","default"],"sources":["/home/user/Desktop/code/demofront/frontend/node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js"],"sourcesContent":["const {\n  slice,\n  forEach\n} = [];\nfunction defaults(obj) {\n  forEach.call(slice.call(arguments, 1), source => {\n    if (source) {\n      for (const prop in source) {\n        if (obj[prop] === undefined) obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n}\nfunction hasXSS(input) {\n  if (typeof input !== 'string') return false;\n\n  // Common XSS attack patterns\n  const xssPatterns = [/<\\s*script.*?>/i, /<\\s*\\/\\s*script\\s*>/i, /<\\s*img.*?on\\w+\\s*=/i, /<\\s*\\w+\\s*on\\w+\\s*=.*?>/i, /javascript\\s*:/i, /vbscript\\s*:/i, /expression\\s*\\(/i, /eval\\s*\\(/i, /alert\\s*\\(/i, /document\\.cookie/i, /document\\.write\\s*\\(/i, /window\\.location/i, /innerHTML/i];\n  return xssPatterns.some(pattern => pattern.test(input));\n}\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nconst serializeCookie = function (name, val) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    path: '/'\n  };\n  const opt = options;\n  const value = encodeURIComponent(val);\n  let str = `${name}=${value}`;\n  if (opt.maxAge > 0) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += `; Max-Age=${Math.floor(maxAge)}`;\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n    str += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n    str += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n    str += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) str += '; HttpOnly';\n  if (opt.secure) str += '; Secure';\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      case 'none':\n        str += '; SameSite=None';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n  if (opt.partitioned) str += '; Partitioned';\n  return str;\n};\nconst cookie = {\n  create(name, value, minutes, domain) {\n    let cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      path: '/',\n      sameSite: 'strict'\n    };\n    if (minutes) {\n      cookieOptions.expires = new Date();\n      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n    }\n    if (domain) cookieOptions.domain = domain;\n    document.cookie = serializeCookie(name, value, cookieOptions);\n  },\n  read(name) {\n    const nameEQ = `${name}=`;\n    const ca = document.cookie.split(';');\n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n    }\n    return null;\n  },\n  remove(name, domain) {\n    this.create(name, '', -1, domain);\n  }\n};\nvar cookie$1 = {\n  name: 'cookie',\n  // Deconstruct the options object and extract the lookupCookie property\n  lookup(_ref) {\n    let {\n      lookupCookie\n    } = _ref;\n    if (lookupCookie && typeof document !== 'undefined') {\n      return cookie.read(lookupCookie) || undefined;\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupCookie,\n      cookieMinutes,\n      cookieDomain,\n      cookieOptions\n    } = _ref2;\n    if (lookupCookie && typeof document !== 'undefined') {\n      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);\n    }\n  }\n};\n\nvar querystring = {\n  name: 'querystring',\n  // Deconstruct the options object and extract the lookupQuerystring property\n  lookup(_ref) {\n    let {\n      lookupQuerystring\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      let {\n        search\n      } = window.location;\n      if (!window.location.search && window.location.hash?.indexOf('?') > -1) {\n        search = window.location.hash.substring(window.location.hash.indexOf('?'));\n      }\n      const query = search.substring(1);\n      const params = query.split('&');\n      for (let i = 0; i < params.length; i++) {\n        const pos = params[i].indexOf('=');\n        if (pos > 0) {\n          const key = params[i].substring(0, pos);\n          if (key === lookupQuerystring) {\n            found = params[i].substring(pos + 1);\n          }\n        }\n      }\n    }\n    return found;\n  }\n};\n\nvar hash = {\n  name: 'hash',\n  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property\n  lookup(_ref) {\n    let {\n      lookupHash,\n      lookupFromHashIndex\n    } = _ref;\n    let found;\n    if (typeof window !== 'undefined') {\n      const {\n        hash\n      } = window.location;\n      if (hash && hash.length > 2) {\n        const query = hash.substring(1);\n        if (lookupHash) {\n          const params = query.split('&');\n          for (let i = 0; i < params.length; i++) {\n            const pos = params[i].indexOf('=');\n            if (pos > 0) {\n              const key = params[i].substring(0, pos);\n              if (key === lookupHash) {\n                found = params[i].substring(pos + 1);\n              }\n            }\n          }\n        }\n        if (found) return found;\n        if (!found && lookupFromHashIndex > -1) {\n          const language = hash.match(/\\/([a-zA-Z-]*)/g);\n          if (!Array.isArray(language)) return undefined;\n          const index = typeof lookupFromHashIndex === 'number' ? lookupFromHashIndex : 0;\n          return language[index]?.replace('/', '');\n        }\n      }\n    }\n    return found;\n  }\n};\n\nlet hasLocalStorageSupport = null;\nconst localStorageAvailable = () => {\n  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n  try {\n    hasLocalStorageSupport = typeof window !== 'undefined' && window.localStorage !== null;\n    if (!hasLocalStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.localStorage.setItem(testKey, 'foo');\n    window.localStorage.removeItem(testKey);\n  } catch (e) {\n    hasLocalStorageSupport = false;\n  }\n  return hasLocalStorageSupport;\n};\nvar localStorage = {\n  name: 'localStorage',\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  lookup(_ref) {\n    let {\n      lookupLocalStorage\n    } = _ref;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      return window.localStorage.getItem(lookupLocalStorage) || undefined; // Undefined ensures type consistency with the previous version of this function\n    }\n    return undefined;\n  },\n  // Deconstruct the options object and extract the lookupLocalStorage property\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupLocalStorage\n    } = _ref2;\n    if (lookupLocalStorage && localStorageAvailable()) {\n      window.localStorage.setItem(lookupLocalStorage, lng);\n    }\n  }\n};\n\nlet hasSessionStorageSupport = null;\nconst sessionStorageAvailable = () => {\n  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n  try {\n    hasSessionStorageSupport = typeof window !== 'undefined' && window.sessionStorage !== null;\n    if (!hasSessionStorageSupport) {\n      return false;\n    }\n    const testKey = 'i18next.translate.boo';\n    window.sessionStorage.setItem(testKey, 'foo');\n    window.sessionStorage.removeItem(testKey);\n  } catch (e) {\n    hasSessionStorageSupport = false;\n  }\n  return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n  name: 'sessionStorage',\n  lookup(_ref) {\n    let {\n      lookupSessionStorage\n    } = _ref;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      return window.sessionStorage.getItem(lookupSessionStorage) || undefined;\n    }\n    return undefined;\n  },\n  cacheUserLanguage(lng, _ref2) {\n    let {\n      lookupSessionStorage\n    } = _ref2;\n    if (lookupSessionStorage && sessionStorageAvailable()) {\n      window.sessionStorage.setItem(lookupSessionStorage, lng);\n    }\n  }\n};\n\nvar navigator$1 = {\n  name: 'navigator',\n  lookup(options) {\n    const found = [];\n    if (typeof navigator !== 'undefined') {\n      const {\n        languages,\n        userLanguage,\n        language\n      } = navigator;\n      if (languages) {\n        // chrome only; not an array, so can't use .push.apply instead of iterating\n        for (let i = 0; i < languages.length; i++) {\n          found.push(languages[i]);\n        }\n      }\n      if (userLanguage) {\n        found.push(userLanguage);\n      }\n      if (language) {\n        found.push(language);\n      }\n    }\n    return found.length > 0 ? found : undefined;\n  }\n};\n\nvar htmlTag = {\n  name: 'htmlTag',\n  // Deconstruct the options object and extract the htmlTag property\n  lookup(_ref) {\n    let {\n      htmlTag\n    } = _ref;\n    let found;\n    const internalHtmlTag = htmlTag || (typeof document !== 'undefined' ? document.documentElement : null);\n    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === 'function') {\n      found = internalHtmlTag.getAttribute('lang');\n    }\n    return found;\n  }\n};\n\nvar path = {\n  name: 'path',\n  // Deconstruct the options object and extract the lookupFromPathIndex property\n  lookup(_ref) {\n    let {\n      lookupFromPathIndex\n    } = _ref;\n    if (typeof window === 'undefined') return undefined;\n    const language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n    if (!Array.isArray(language)) return undefined;\n    const index = typeof lookupFromPathIndex === 'number' ? lookupFromPathIndex : 0;\n    return language[index]?.replace('/', '');\n  }\n};\n\nvar subdomain = {\n  name: 'subdomain',\n  lookup(_ref) {\n    let {\n      lookupFromSubdomainIndex\n    } = _ref;\n    // If given get the subdomain index else 1\n    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === 'number' ? lookupFromSubdomainIndex + 1 : 1;\n    // get all matches if window.location. is existing\n    // first item of match is the match itself and the second is the first group match which should be the first subdomain match\n    // is the hostname no public domain get the or option of localhost\n    const language = typeof window !== 'undefined' && window.location?.hostname?.match(/^(\\w{2,5})\\.(([a-z0-9-]{1,63}\\.[a-z]{2,6})|localhost)/i);\n\n    // if there is no match (null) return undefined\n    if (!language) return undefined;\n    // return the given group match\n    return language[internalLookupFromSubdomainIndex];\n  }\n};\n\n// some environments, throws when accessing document.cookie\nlet canCookies = false;\ntry {\n  // eslint-disable-next-line no-unused-expressions\n  document.cookie;\n  canCookies = true;\n  // eslint-disable-next-line no-empty\n} catch (e) {}\nconst order = ['querystring', 'cookie', 'localStorage', 'sessionStorage', 'navigator', 'htmlTag'];\nif (!canCookies) order.splice(1, 1);\nconst getDefaults = () => ({\n  order,\n  lookupQuerystring: 'lng',\n  lookupCookie: 'i18next',\n  lookupLocalStorage: 'i18nextLng',\n  lookupSessionStorage: 'i18nextLng',\n  // cache user language\n  caches: ['localStorage'],\n  excludeCacheFor: ['cimode'],\n  // cookieMinutes: 10,\n  // cookieDomain: 'myDomain'\n\n  convertDetectedLanguage: l => l\n});\nclass Browser {\n  constructor(services) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.type = 'languageDetector';\n    this.detectors = {};\n    this.init(services, options);\n  }\n  init() {\n    let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      languageUtils: {}\n    };\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.services = services;\n    this.options = defaults(options, this.options || {}, getDefaults());\n    if (typeof this.options.convertDetectedLanguage === 'string' && this.options.convertDetectedLanguage.indexOf('15897') > -1) {\n      this.options.convertDetectedLanguage = l => l.replace('-', '_');\n    }\n\n    // backwards compatibility\n    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n    this.i18nOptions = i18nOptions;\n    this.addDetector(cookie$1);\n    this.addDetector(querystring);\n    this.addDetector(localStorage);\n    this.addDetector(sessionStorage);\n    this.addDetector(navigator$1);\n    this.addDetector(htmlTag);\n    this.addDetector(path);\n    this.addDetector(subdomain);\n    this.addDetector(hash);\n  }\n  addDetector(detector) {\n    this.detectors[detector.name] = detector;\n    return this;\n  }\n  detect() {\n    let detectionOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.order;\n    let detected = [];\n    detectionOrder.forEach(detectorName => {\n      if (this.detectors[detectorName]) {\n        let lookup = this.detectors[detectorName].lookup(this.options);\n        if (lookup && typeof lookup === 'string') lookup = [lookup];\n        if (lookup) detected = detected.concat(lookup);\n      }\n    });\n    detected = detected.filter(d => d !== undefined && d !== null && !hasXSS(d)).map(d => this.options.convertDetectedLanguage(d));\n    if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n    return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n  }\n  cacheUserLanguage(lng) {\n    let caches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.caches;\n    if (!caches) return;\n    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n    caches.forEach(cacheName => {\n      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);\n    });\n  }\n}\nBrowser.type = 'languageDetector';\n\nexport { Browser as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}